---
title: Docker Run 命令详解
lang: zh-CN
tags: 
  - Docker
  - Linux
  - 容器
  - 虚拟化
categories: 
  - [学习, Docker]
  - [日常记录]
---
Docker 在隔离的容器中运行进程。容器是在主机上运行的进程。主机可以是本地或远程的。当执行 `docker run` 时，运行的容器进程是独立的，因为它有自己的文件系统、自己的网络和自己的独立于主机的进程树。

以下介绍了如何在运行时使用 `docker run` 命令定义容器的资源。

## `docker run` 命令的一般形式

基本的 `docker run` 命令采用以下形式：

```bash
\$ docker run [选项] IMAGE[:标签|@摘要] [命令] [参数...]
```

`docker run` 命令必须指定从中生成容器的镜像。镜像开发人员可以定义与以下内容相关的镜像默认值：

* 分离或前台运行；
* 容器标识；
* 网络设置；
* 对CPU和内存的运行时约束。

通过 `docker run [选项]` 用户可以添加或覆盖开发人员设置的镜像默认值。此外，用户可以覆盖几乎所有由 Docker 运行时本身设置的默认值。也正因为如此，`docker run` 比任何其他 Docker 命令都有更多选项。

> 🟢 根据你的 Docker 系统配置，你可能需要在 `docker run` 命令前面加上 `sudo` 以确保命令正常执行生效。为了避免在 docker 命令中使用 sudo，你的系统管理员可以创建一个名为 docker 的 Unix 组并向其中添加 docker 操作用户。

## 仅用户可指定的选项

仅执行 `docker run` 命令的用户可指定以下命令执行时的选项：

* 独立进程或前台执行
  * 独立进程（`-d` 选项）
  * 前台执行
* 容器标识
  * 名称（`--name` 选项）
  * PID 值
* IPC 设置（`--ipc`）
* 网络设置
* 重启策略（`--restart`）
* 清理（`--rm`）
* 运行时资源约束
* 运行时特权及 Linux capabilities

### 独立进程或前台执行

当启动了一个 Docker 容器，你必须先决定你是否想在后台以“分离”的模式或者默认在前台运行容器，可以使用 `-d[=<true|false>]` 选项来指定分离式模式，容器会在后台运行并打印出该容器的 id。

根据设计，当用于运行容器的根进程退出时，以分离模式启动的容器也会退出，除非你还指定了 `-rm` 选项。如果将 `-d` 与 `-rm` 一起使用，当容器退出或守护程序退出时(无论哪个先退出)，容器将被删除。

不要向分离模式运行的容器传递 `service xxx start` 的命令。如以下命令尝试创建容器后启动 nginx 服务。

```bash
\$ docker run -d -p 80:80 my_image service nginx start
```

即使这也会成功的启动容器内部的 nginx 服务，但是它不符合分离的容器范例，因为随着根进程（`service nginx start`）的退出，分离式容器也会跟着停止，从而导致 nginx 服务启动了却不能用。要启动一个进程如 nginx web 服务器应该按照下述方法：

```bash
\$ docker run -d -p 80:80 my_image nginx -g 'daemon off;'
```

要使用分离的容器进行输入/输出则必须使用网络连接或共享卷，因为该容器不会监听运行 `docker run` 的命令行。

为了将分离出去的容器转至前台运行，可以使用 `docker attach` 命令。将运行于前台的容器切至后台运行可以使用 `Ctrl` + `p` + `q` 快捷键。

### 前台运行

在前台模式下（默认模式当未指定 `-d` 选项），`docker run` 可以启动容器中的进程并且将当前终端附加到该进程的标准输入、输出以及标准错误流中。它甚至可以“假装”成为一个 TTY 会话（如大多数命令行可执行文件期望的那样）并且传递信号。以下这些选项都是可配置的：

> -a=[]           ：附加到标准输入、标准输出和 / 或标准错误流
> -t              ：分配一个伪 TTY
> --sig-proxy=true：将所有收到的信号代理到进程(仅限非TTY模式)
> -i              ：即使没有连接，也保持标准输入流打开

如果你没有指定 `-a` 选项，Docker 就会将进程的标准输入、错误流附加到当前终端中，你也可以通过 `-a` 选项指定哪个流进行附加，比如：

```bash
\$ docker run -a stdin -a stdout -i -t ubuntu /bin/bash
```

对于交互式进程（如命令行 shell），必须一起指定 `-i` 和 `-t` 选项来为容器进程分配一个 TTY，这两个选项常被简写为 `-it`。当客户端从管道中接收标准输入流时指定 `-t` 选项通常是被禁止的，比如：

```bash
\$ echo test | docker run -i busybox cat
```

> 🔴 注意：在容器中运行的 PID 为 1 的进程会被 Linux 特殊看待：它会忽略任何信号的默认行为。最终就会导致收到 *SIGINT* 和 *SIGTERM* 信号的进程不会终止除非它被编码进行指定。

## 容器标识

### 容器名称（--name）

用户可以通过三种方式来标识容器：

| 标识符类型 | 例子                                                 |
|------------|----------------------------------------------------|
| UUID 长标识符 | “f78375b1c487e03c9438c729345e54db9d20cfa2ac1fc3494b6eb60872e74778” |
| UUID 短标识符 | “f78375b1c487” |
| 名称 | “evil_ptolemy” |

其中，UUID 标识符由 Docker 守护程序生成。如果未通过 `--name` 选项来给容器赋予名称，则守护程序会生成一串随机字符来自动命名该容器。给容器进行有意义的命名是一个比较好的习惯。如果你制定了容器的名称，就可以在 Docker 网络中引用容器时使用它，不论是前台还是后台运行的容器。

> 默认网桥网络上的容器必须被链接以通过名称进行通信。

最后，为了便于自动化，你可以让 Docker 将容器的 ID 写入到你选择的文件中。这类似于一些程序会将自身进程 ID 写入到文件中去，正如你见过的 PID 文件。

```bash
--cidfile=""：将容器 ID 写入文件
```

### 镜像[\:标签]

虽然严格来说这不是一种标识容器的方法，但是你可以通过将 image[\:tag] 添加到命令中来指定您想要运行容器的镜像版本。比如：`docker run ubuntu:14.04`。

### 镜像[\@摘要]

使用 v2 或更高版本镜像格式的镜像有一个称为摘要的内容可寻址标识符。只要用于生成镜像的输入不变，摘要值就是可预测和可参考的。

以下示例使用在运行 alpine 镜像时使用了 sha256:9cacb71397b640ECA97488cf08582AE4068513101088e9f96c9814bfda95e0 摘要：

```bash
\$ docker run alpine@sha256:9cacb71397b640eca97488cf08582ae4e4068513101088e9f96c9814bfda95e0 date
```

## PID 设置（--pid）

> --pid="" ：为容器设置 PID（进程） 命名空间模式。可选值：**container:\<name\|id\>**：加入其他容器的 PID 命名空间；**host**：使用容器中的主机的 PID 命名空间。

默认情况下，所有容器都启用了 PID 命名空间。

PID 命名空间提供了进程的分离。PID 命名空间删除了系统进程的视图，并允许重用进程 ID，包括 pid 1。

在某些情况下，你希望你的容器共享主机的进程名称空间，基本上允许容器内的进程看到系统上的所有进程。例如，您可以使用像 `strace` 或 `gdb` 这样的调试工具构建一个容器，但是在调试容器中的进程时，你希望使用这些工具。

### 例子：在容器中执行 \`htop\`

创建 Dockerfile:

```dockerfile
FROM alpine:latest
RUN apk add --update htop && rm -rf /var/cache/apk/*
CMD ["htop"]
```

构建此 Dockerfile  并将镜像标记为 myhtop：

```bash
\$ docker build -t myhtop .
```

使用以下命令在容器中运行 `htop` 命令：

```bash
\$ docker run -it --rm --pid=host myhtop
```

加入其他可以被用来调试该容器的 pid 命名空间。

### 例子

开启一个运行 redis 服务的容器：

```bash
\$ docker run --name myredis -d redis
```

通过运行含有 `strace` 的其他容器来调试 redis 容器：

```bash
\$ docker run -it --pid=container:my-redis my_strace_docker_image bash
\$ strace -p 1
```

## UTS 设置（--uts）

> --uts=""  : 设置容器的 UTS 命名空间。可选值：**host** 值代表使用主机的 uts 值。

UTS 命名空间参数设置旨在使容器进程对于运行于目标 uts 设置中的目标进程的主机名和域可见。默认情况下所有的容器，包括指定了 `--network=host` 命名空间的容器，都有自己的 `uts` 命名空间。`--uts=host` 将会使容器使用和主机一样的 `uts` 命名空间。在指定了 `--uts=host` 设置后将不能再单独指定 `--hostname` 和 `--domainname` 设置。

如果希望容器的主机名随着主机的主机名的更改而更改，即容器与主机共享主机名，更好的做法是从容器中更改主机的主机名。

## IPC 设置（--ipc）

> --ipc="MODE"  : 设置容器的 IPC 模式

可以接受以下值：

| 值                           | 描述                                             |
| --------------------------- | ---------------------------------------------- |
| 不指定                         | 使用守护程序默认设置                                     |
| none                        | 使用自己私有的 IPC 命名空间，且不挂载 /dev/shm                 |
| private                     | 使用自己私有的 IPC 命名空间                               |
| shareable                   | 使用自己私有的 IPC 命名空间，但允许与其他容器共享此命名空间               |
| container: <\_name-or-ID\_> | 加入其他设置了 `--ipc=shareable` 的容器的命名空间（需指定容器名或 ID） |
| host                        | 使用主机的 IPC 命名空间                                 |

dockerd 守护程序默认会使用 `--ipc=private` 或 `--ipc=shareable` 设置，具体取决于 dockerd 守护程序的版本及配置。

IPC(POSIX/SysV IPC) 命名空间提供了不同命名空间下的共享内存段、信号量以及消息队列的隔离机制。

共享内存段是用于以内存的速度加速进程间通信的一种方法，除此之外还有通过管道或网络堆栈的方法。共享内存通常用于涉及科学计算或金融服务等的数据库和构建的对高性能有要求的应用程序。如果你的这类应用程序被拆分成多个容器就要考虑可能需要共享这些容器之间的 IPC 机制，做法是对主容器使用 `--ipc=shareable` 的设置、其他容器使用 `--ipc=container:<主容器名或其 ID>` 的设置。

## 网络设置

> --dns=[]           : 为容器指定域名服务器
> --network="bridge" : 指定容器接入网络的方式，可选值：**bridge** 在默认的 Docker 网桥上创建网络栈（默认）；**none** 不联网；**container:\<name|id\>** 复用现有容器的网络栈；**host** 使用 Dockr 主机的网络栈；**\<network-name\>|\<network-id\>** 连接至用户自定义的网络。
> --network-alias=[] : 为容器添加网络范围的别名
> --add-host=""      : 在 /etc/hosts 上自动添加一行记录 (host:IP)
> --mac-address=""   : 指定容器物理设备的 MAC 地址
> --ip=""            : 指定容器物理设备的 IPv4 地址
> --ip6=""           : 指定容器物理设备的 IPv6 地址
> --link-local-ip=[] : 指定一个或多个容器的物理设备的链路的本地 IPv4 或 IPv6 地址

默认情况下，所有容器都会启用网络且对网络出口不做任何限制。可以通过指定 `--network none` 选项来禁用容器的网络，在这种情况下，可以仅通过文件、标准输入输出流来进行 I/O。

要实现不同容器之间的互通只能通过默认的网桥模式设置，链接特性是一种经典的特性，更推荐使用基于链接特性的 Docker 网络驱动。

你的容器会默认使用主机设置的 DNS 服务器，但是你可以通过指定 `--dns=<DNS>` 选项来指定容器网络的 DNS 设置。

默认情况下，容器会根据自身分配的 ip 地址来生成自己的 MAC 地址，可以通过指定 `--mac-address=<MAC>` 选项（MAC 地址的分隔符使用英文冒号，如 12:34:56:78:9a:bc）来显式指定容器的 MAC 地址。需注意 Docker 不会进行手动分配的 MAC 地址的唯一性检查。

### Network:none

容器不会有到外部网络的虚拟设备及路由，但内部仍会有一个回环接口。

### Network:bridge

将网络设置为桥接模式后，容器将使用 docker 的默认网络设置。在主机上设置一个桥，通常命名为 docker0，将为容器创建一对 veth 接口。veth对的一端将保留在连接到网桥的主机上，而 veth 对的另一端除了放在环回接口之外，还将放在容器的命名空间内以为网桥网络上的容器分配一个IP 地址，流量将通过该网桥路由到该容器。

默认情况下，容器可以通过它们的 IP 地址进行通信。要通过名字交流，它们必须连接在一起。

### Network:host

将网络设置为主机模式后，容器将共享主机的网络堆栈，并且来自主机的所有接口将对容器可用。容器的主机名将与主机系统上的主机名相匹配。请注意 `--mac-address` 选项在主机网络模式下无效。即使在主机网络模式下，默认情况下容器也有自己的 UTS 命名空间。因此，在主机网络模式下允许使用 `--hostname` 和 `--domainname` 选项，它们只会更改容器内的主机名和域名。与 `--hostname` 类似，可以在主机网络模式下使用 `--add-host`、`--dns`、`--dns-search` 和 `--dns-option` 选项。这些选项将会更新容器中的 /etc/hosts 或 /etc/resolv.conf。不会对主机上的 /etc/hosts 和 /etc/resolv.conf 进行任何更改。

与默认网桥模式相比，主机模式提供了明显更好的网络性能，因为它使用主机的本机网络堆栈，而网桥必须通过 dockerd 守护程序经历一级虚拟化。当容器的网络性能至关重要时，例如生产负载平衡器或高性能 Web 服务器，建议以此模式运行容器。

> 🔵 注意：`--network="host"` 给予容器对本地系统服务（如 D-bus）的完全访问权，因此被认为是不安全的。

### Network:container

将网络设置为容器模式后，一个容器将共享另一个容器的网络堆栈。另一个容器的名称必须以 `--network container:<名称|id>` 的格式提供。注意 `--add-host`、`--hostname`、`--dns`、`--dns-search`、`--dns-option` 和 `--mac-address` 在容器网络模式中无效，而 `--publish`、`--publish-all`、`--expose` 在容器网络模式中也无效。

以下示例运行 redis 容器，将 redis 绑定到本地主机，然后运行 `redis-cli` 命令并通过本地主机接口连接到Redis服务器。

```bash
\$ docker run -d --name redis example/redis --bind 127.0.0.1
\$ docker run --rm -it --network container:redis example/redis-cli -h 127.0.0.1
```

### 用户定义的网络

你可以使用 Docker 网络驱动程序或外部网络驱动程序插件来创建网络。你可以将多个容器连接到同一网络。一旦连接到用户定义的网络，这些容器就可以仅使用另一个容器的 IP 地址或域名轻松地进行通信。

对于支持多主机连接的覆盖网络或自定义插件，连接到同一多主机网络但从不同引擎启动的容器也可以通过这种方式进行通信。

以下示例使用内置网桥网络驱动程序创建网络，并在创建的网络中运行容器：

```bash
\$ docker network create -d bridge my-net
\$ docker run --network=my-net -itd --name=container3 busybox
```

### 管理 /etc/hosts 文件

你的容器将在 /etc/hosts 中包含一些行，这些行定义了容器本身的主机名以及 localhost 和其他一些常见内容。`--add-host` 标志可用于向 /etc/hosts 添加额外的行。

```bash
\$ docker run -it --add-host db-static:86.75.30.9 ubuntu cat /etc/hosts
127.0.0.1       localhost
::1     localhost ip6-localhost ip6-loopback
fe00::0 ip6-localnet
ff00::0 ip6-mcastprefix
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters
86.75.30.9      db-static
172.17.0.2      af78fbac55c9
```

如果一个容器连接到默认桥接网络并与其他容器链接，则该容器的 /etc/hosts 文件将使用链接容器的名称进行更新。

> 🔵 注意：由于 Docker 可能会实时更新容器的 /etc/hosts 文件，因此可能会出现容器内的进程最终读取空的或不完整的 /etc/hosts 文件的情况。在大多数情况下，再次重试读取应该可以解决问题。

## 重启策略（--restart）

使用 `docker run` 上的 `--restart` 标志可以指定容器的重启策略，决定容器在退出时应不应该以及如何重启。

当重启策略在容器上被激活时，它将在 `docker ps` 中显示为 **Up** 或 **Restarting**。使用 `docker events` 查看重启策略的效果也很有用。

| 策略                     | 效果                                                         |
| ------------------------ | ------------------------------------------------------------ |
| no                       | （默认）容器退出后不会自动重启。                             |
| on-failure[:max-retries] | 当容器退出并返回一个非零状态值时尝试重启，可以指定最大重试次数。 |
| always                   | 无论退出状态如何，都要重启容器。当指定 always 时，Docker 守护进程将尝试无限期地重新启动容器。无论容器的当前状态如何，容器也总是在守护进程启动时启动。 |
| unless-stopped           | 无论退出状态如何，都要重启容器，包括在守护进程启动时，除非容器在 Docker 守护进程停止之前处于停止状态。 |

在每次重新启动之前，增加延迟(从 100 毫秒开始，是之前延迟的两倍),以防止服务器洪流。这意味着守护进程将等待 100 毫秒，然后 200 毫秒，400，800，1600，等等，直到达到失败极限，最大延迟1分钟，或者当您执行 `docker stop` 或 `docker rm -f` 容器。

如果容器成功重启(容器启动并运行至少 10 秒)，延迟将重置为默认值100毫秒。

使用失败时策略时，您可以指定 Docker 尝试重新启动容器的最大次数。默认情况下，Docker 将永远尝试重新启动容器。可以通过 `docker inspect` 获得容器的(尝试)重启次数。例如，获取容器“my-container”的重启次数:

```bash
\$ docker inspect -f "{{ .RestartCount }}" my-container
```

或者获得上次容器(重新)启动的时间:

```bash
\$ docker inspect -f "{{ .State.StartedAt }}" my-container
```

将 `--restart` (重新启动策略)与 `--rm` (清理)标志结合使用会导致错误。容器重启时，连接的客户端会断开连接。

## 自动清理（--rm）

默认情况下，容器的文件系统即使在容器退出后仍然存在。这使得调试容易得多(因为您可以检查最终状态),并且在默认情况下保留所有数据。但是如果你运行的是短期前台进程，这些容器文件系统会不断堆积起来。相反，如果您希望 Docker 在容器退出时自动清理容器并删除文件系统，您可以添加 `--rm` 标志:

> --rm=false: 容器退出时自动清理
